{"ast":null,"code":"import { blackboard } from '../core/Blackboard';\n\n/**\n * ==================================================================================\n * SHAM ARCHITECT SYS - PRO GEN 5.0 (THE \"ULTIMATE\" SOLVER)\n * ==================================================================================\n * * ARCHITECTURE:\n * 1. KNOWLEDGE BASE: Defines strict rules (Min dimensions, adjacency scores).\n * 2. GEOMETRY ENGINE: Handles 2D boolean operations, collision, and alignment.\n * 3. AGENTS:\n * - ZONING AGENT: Assigns rooms to floors and \"Privacy Clusters\".\n * - TOPOLOGY AGENT: Defines the ideal \"Graph\" (Room A must touch Room B).\n * - LAYOUT SOLVER: A Monte-Carlo-lite solver that attempts to pack rooms \n * into the shell while minimizing a \"Badness Cost\".\n * - STRUCTURAL AGENT: Generates walls based on the final solved regions.\n */\n\nconst LOG = msg => console.log(`[Architect Core] ${msg}`);\n\n// ==================================================================================\n// 1. ARCHITECTURAL KNOWLEDGE BASE (The Rules)\n// ==================================================================================\n_c = LOG;\nconst ROOM_SPECS = {\n  // PUBLIC ZONES\n  'living': {\n    minDim: 12,\n    maxDim: 22,\n    idealRatio: 1.3,\n    priority: 10,\n    color: '#fff7ed'\n  },\n  'dining': {\n    minDim: 10,\n    maxDim: 16,\n    idealRatio: 1.2,\n    priority: 8,\n    color: '#fffbeb'\n  },\n  'garage': {\n    minDim: 12,\n    maxDim: 24,\n    idealRatio: 1.1,\n    priority: 9,\n    color: '#f1f5f9'\n  },\n  'kitchen': {\n    minDim: 10,\n    maxDim: 18,\n    idealRatio: 1.4,\n    priority: 9,\n    color: '#ecfeff'\n  },\n  // PRIVATE ZONES\n  'master-bed': {\n    minDim: 13,\n    maxDim: 18,\n    idealRatio: 1.1,\n    priority: 10,\n    color: '#f0f9ff'\n  },\n  'bedroom': {\n    minDim: 10,\n    maxDim: 14,\n    idealRatio: 1.0,\n    priority: 8,\n    color: '#f0f9ff'\n  },\n  'study': {\n    minDim: 8,\n    maxDim: 12,\n    idealRatio: 1.0,\n    priority: 5,\n    color: '#fefce8'\n  },\n  'library': {\n    minDim: 10,\n    maxDim: 14,\n    idealRatio: 1.2,\n    priority: 6,\n    color: '#fefce8'\n  },\n  // SERVICE / WET ZONES (The \"Parasitic\" Rooms)\n  'bathroom': {\n    minDim: 5,\n    maxDim: 10,\n    idealRatio: 1.2,\n    priority: 7,\n    color: '#f8fafc'\n  },\n  'utility': {\n    minDim: 6,\n    maxDim: 10,\n    idealRatio: 1.5,\n    priority: 4,\n    color: '#f3f4f6'\n  },\n  'store': {\n    minDim: 4,\n    maxDim: 8,\n    idealRatio: 1.0,\n    priority: 3,\n    color: '#cbd5e1'\n  },\n  'prayer': {\n    minDim: 6,\n    maxDim: 10,\n    idealRatio: 1.0,\n    priority: 5,\n    color: '#f0fdf4'\n  },\n  // CIRCULATION\n  'hallway': {\n    minDim: 4,\n    maxDim: 8,\n    idealRatio: 4.0,\n    priority: 1,\n    color: '#ffffff'\n  },\n  'stairs': {\n    minDim: 8,\n    maxDim: 12,\n    idealRatio: 1.0,\n    priority: 10,\n    color: '#e2e8f0'\n  }\n};\nconst ADJACENCY_RULES = [\n// High Priority Constraints\n{\n  r1: 'kitchen',\n  r2: 'dining',\n  score: 100\n}, {\n  r1: 'master-bed',\n  r2: 'bathroom',\n  score: 90\n},\n// Ensuite\n{\n  r1: 'living',\n  r2: 'dining',\n  score: 50\n}, {\n  r1: 'garage',\n  r2: 'utility',\n  score: 40\n}, {\n  r1: 'kitchen',\n  r2: 'utility',\n  score: 40\n}];\n\n// ==================================================================================\n// 2. GEOMETRY ENGINE (Helper Class)\n// ==================================================================================\n\nclass Rect {\n  constructor(x, y, w, h) {\n    this.x = x;\n    this.y = y;\n    this.w = w;\n    this.h = h;\n  }\n  get area() {\n    return this.w * this.h;\n  }\n  get ratio() {\n    return this.w > this.h ? this.w / this.h : this.h / this.w;\n  }\n  get right() {\n    return this.x + this.w;\n  }\n  get bottom() {\n    return this.y + this.h;\n  }\n\n  // Returns true if this rect overlaps or touches another\n  intersects(other) {\n    return !(this.right <= other.x || this.x >= other.right || this.bottom <= other.y || this.y >= other.bottom);\n  }\n\n  // Returns true if this rect strictly contains another\n  contains(other) {\n    return this.x <= other.x && this.right >= other.right && this.y <= other.y && this.bottom >= other.bottom;\n  }\n\n  // Slice operations\n  splitVert(ratio) {\n    // Split at X\n    const w1 = this.w * ratio;\n    return [new Rect(this.x, this.y, w1, this.h), new Rect(this.x + w1, this.y, this.w - w1, this.h)];\n  }\n  splitHorz(ratio) {\n    // Split at Y\n    const h1 = this.h * ratio;\n    return [new Rect(this.x, this.y, this.w, h1), new Rect(this.x, this.y + h1, this.w, this.h - h1)];\n  }\n}\n\n// ==================================================================================\n// 3. AGENT IMPLEMENTATIONS\n// ==================================================================================\n\n// --- AGENT 1: ZONING & INVENTORY ---\n// Responsible for deciding WHAT goes on WHICH floor and creating \"Clusters\".\n// e.g. \"Master Bed\" + \"Master Bath\" becomes a single logical unit \"Master Suite\".\n\nconst ZoningAgent = async config => {\n  LOG('Parsing inventory and creating logical clusters...');\n  const pad = 4;\n  const buildW = config.width - pad * 2;\n  const buildD = config.depth - pad * 2;\n  blackboard.write('siteBoundary', new Rect(pad, pad, buildW, buildD));\n\n  // 1. Clone Inventory\n  const inventory = {\n    ...config.rooms\n  };\n  const floorPlans = Array.from({\n    length: config.floors\n  }, () => ({\n    clusters: [],\n    // A cluster is { name: 'Master Suite', rooms: ['master-bed', 'bathroom'], priority: 10 }\n    singles: [] // Loose rooms like 'living'\n  }));\n\n  // 2. Helper to assign to floor\n  const assign = (floorIdx, item, type = 'single') => {\n    const f = Math.min(floorIdx, config.floors - 1);\n    if (type === 'cluster') floorPlans[f].clusters.push(item);else floorPlans[f].singles.push(item);\n  };\n\n  // 3. Logic: Create Master Suite (Always tries to pair a bath with master)\n  if (inventory.bedroom > 0) {\n    // Check if we can make a suite\n    const hasBath = inventory.bathroom > 0;\n    const roomsInSuite = ['master-bed'];\n    inventory.bedroom--;\n    if (hasBath) {\n      roomsInSuite.push('bathroom');\n      inventory.bathroom--;\n    }\n\n    // Assign Master Suite to highest priority floor (First floor if exists, else Ground)\n    const targetFloor = config.floors > 1 ? 1 : 0;\n    assign(targetFloor, {\n      type: 'SUITE',\n      rooms: roomsInSuite,\n      id: 'master-suite'\n    }, 'cluster');\n  }\n\n  // 4. Create Standard Bedroom Clusters (Bed + Bath if available)\n  // We try to pair bathrooms to bedrooms to avoid \"floating\" bathrooms\n  let currentFloor = config.floors > 1 ? 1 : 0;\n  while (inventory.bedroom > 0) {\n    const roomsInCluster = ['bedroom'];\n    inventory.bedroom--;\n\n    // 50% chance to grab a bath if we have plenty, or if it's the only bed left\n    if (inventory.bathroom > 0) {\n      roomsInCluster.push('bathroom');\n      inventory.bathroom--;\n    }\n    assign(currentFloor, {\n      type: 'BED-CLUSTER',\n      rooms: roomsInCluster,\n      id: `bed-cluster-${inventory.bedroom}`\n    }, 'cluster');\n\n    // Rotate floors\n    if (config.floors > 2 && currentFloor < config.floors - 1) currentFloor++;else if (config.floors > 1) currentFloor = 1;\n  }\n\n  // 5. Ground Floor Service Cluster (Kitchen + Dining + Utility)\n  // We group them so they stay together\n  const serviceRooms = [];\n  if (inventory.kitchen > 0) {\n    serviceRooms.push('kitchen');\n    inventory.kitchen--;\n  }\n  if (inventory.dining > 0) {\n    serviceRooms.push('dining');\n    inventory.dining--;\n  }\n  if (inventory.utility > 0) {\n    serviceRooms.push('utility');\n    inventory.utility--;\n  }\n  if (inventory.store > 0) {\n    serviceRooms.push('store');\n    inventory.store--;\n  }\n  if (serviceRooms.length > 0) {\n    assign(0, {\n      type: 'SERVICE-CORE',\n      rooms: serviceRooms,\n      id: 'service-core'\n    }, 'cluster');\n  }\n\n  // 6. Remaining Rooms (Living, Garage, Prayer, Floating Baths)\n  const groundPriority = ['garage', 'living', 'prayer', 'bathroom']; // Bath here is guest bath\n\n  groundPriority.forEach(r => {\n    while (inventory[r] > 0) {\n      assign(0, {\n        type: 'SINGLE',\n        rooms: [r],\n        id: `${r}-gen`\n      }, 'cluster');\n      inventory[r]--;\n    }\n  });\n\n  // Dump anything else (Library etc)\n  Object.keys(inventory).forEach(k => {\n    while (inventory[k] > 0) {\n      const f = k === 'library' || k === 'study' ? config.floors > 1 ? 1 : 0 : 0;\n      assign(f, {\n        type: 'SINGLE',\n        rooms: [k],\n        id: `${k}-misc`\n      }, 'cluster');\n      inventory[k]--;\n    }\n  });\n  blackboard.write('floorPlans', floorPlans);\n  return true;\n};\n\n// --- AGENT 2: LAYOUT SOLVER (The Heavy Lifter) ---\n// Uses a recursive slicing algorithm with \"Aspect Ratio Protection\".\n// Unlike the old version, this explicitly checks if a split would result in a skinny room.\n_c2 = ZoningAgent;\nconst LayoutAgent = async () => {\n  LOG('Solving geometry with Aspect Ratio Constraints...');\n  const site = blackboard.read('siteBoundary');\n  const floorPlans = blackboard.read('floorPlans');\n  const config = blackboard.read('config');\n  const allFloorsRegions = [];\n\n  // CONSTANTS for the solver\n  const SPINE_WIDTH = 6;\n  floorPlans.forEach((plan, floorIdx) => {\n    const regions = [];\n\n    // 1. Setup the Bounds\n    // Define the central hallway spine immediately. This is the anchor.\n    // X Position: Center\n    const spineX = site.x + (site.w - SPINE_WIDTH) / 2;\n    const hallRect = new Rect(spineX, site.y + 6, SPINE_WIDTH, site.h - 10);\n    regions.push({\n      ...hallRect,\n      type: 'hallway',\n      id: 'main-spine'\n    });\n    if (config.floors > 1) {\n      // Place stairs at the back of the hallway\n      const stairRect = new Rect(spineX, hallRect.bottom - 10, SPINE_WIDTH, 10);\n      regions.push({\n        ...stairRect,\n        type: 'stairs',\n        id: 'stairs'\n      });\n      // Shorten hall visually to not overlap stairs\n      hallRect.h -= 10;\n    }\n\n    // 2. We now have two massive empty spaces: LEFT WING and RIGHT WING\n    const leftWing = new Rect(site.x, site.y, (site.w - SPINE_WIDTH) / 2, site.h);\n    const rightWing = new Rect(spineX + SPINE_WIDTH, site.y, (site.w - SPINE_WIDTH) / 2, site.h);\n\n    // 3. Sort Clusters into Wings\n    // Heuristic: \n    // - Garage/Kitchen/Service -> RIGHT WING (Functional)\n    // - Living/Bedrooms -> LEFT WING (Living)\n    // - Master Suite -> Rear Right (Privacy)\n\n    const leftItems = [];\n    const rightItems = [];\n    plan.clusters.forEach(cluster => {\n      const types = cluster.rooms.join(',');\n\n      // Force assignments\n      if (types.includes('garage')) rightItems.push(cluster);else if (types.includes('kitchen')) rightItems.push(cluster);else if (types.includes('utility')) rightItems.push(cluster);else if (types.includes('living')) leftItems.push(cluster);else if (types.includes('master')) rightItems.push(cluster); // Master on right rear usually nice\n      else if (types.includes('bedroom')) leftItems.push(cluster);else {\n        // Balance\n        if (leftItems.length <= rightItems.length) leftItems.push(cluster);else rightItems.push(cluster);\n      }\n    });\n\n    // 4. THE RECURSIVE SOLVER\n    // This function takes a Rect and a list of Clusters.\n    // It subdivides the rect to fit the clusters while respecting ratios.\n\n    const solveSpace = (space, clusters) => {\n      if (clusters.length === 0) return;\n\n      // Base Case: 1 Cluster\n      if (clusters.length === 1) {\n        // We have one cluster (e.g. Master Suite [Bed, Bath]) to fit in 'space'.\n        // We need to subdivide 'space' internally for the rooms in the cluster.\n        solveCluster(space, clusters[0]);\n        return;\n      }\n\n      // Recursive Step: Split the space\n      // Decide split direction based on aspect ratio of the space\n      // If Space is Tall -> Split Horizontally\n      // If Space is Wide -> Split Vertically\n      const isTall = space.h > space.w;\n\n      // We divide the list of clusters into two groups\n      const mid = Math.ceil(clusters.length / 2);\n      const group1 = clusters.slice(0, mid);\n      const group2 = clusters.slice(mid);\n\n      // Calculate weight of each group (heuristic: count of rooms)\n      const w1 = group1.reduce((acc, c) => acc + c.rooms.length, 0);\n      const w2 = group2.reduce((acc, c) => acc + c.rooms.length, 0);\n      const total = w1 + w2;\n      const splitRatio = w1 / total;\n      let r1, r2;\n      if (isTall) {\n        // Horizontal Cut\n        [r1, r2] = space.splitHorz(splitRatio);\n      } else {\n        // Vertical Cut\n        [r1, r2] = space.splitVert(splitRatio);\n      }\n      solveSpace(r1, group1);\n      solveSpace(r2, group2);\n    };\n\n    // 5. CLUSTER SOLVER (The \"Parasitic\" Logic)\n    // Fits [Master Bed, Bath] into a specific rect\n    const solveCluster = (rect, cluster) => {\n      const rooms = cluster.rooms; // e.g. ['master-bed', 'bathroom']\n\n      if (rooms.length === 1) {\n        regions.push({\n          ...rect,\n          type: rooms[0],\n          id: cluster.id\n        });\n        return;\n      }\n\n      // We have multiple rooms. We need to identify the \"Main\" room and the \"Parasites\".\n      // Big rooms: Living, Bed, Kitchen\n      // Small rooms: Bath, Utility, Store\n\n      const smalls = rooms.filter(r => ['bathroom', 'utility', 'store', 'prayer'].includes(r));\n      const bigs = rooms.filter(r => !['bathroom', 'utility', 'store', 'prayer'].includes(r));\n\n      // Strategy: Carve out space for smalls from the rect, give rest to bigs.\n      // Usually carve a strip from the \"back\" or \"side\".\n\n      if (bigs.length === 0) {\n        // All smalls (e.g. Utility + Store). Just split evenly.\n        const subH = rect.h / rooms.length;\n        rooms.forEach((r, i) => {\n          regions.push({\n            x: rect.x,\n            y: rect.y + i * subH,\n            w: rect.w,\n            h: subH,\n            type: r\n          });\n        });\n        return;\n      }\n\n      // We have a Big Room (e.g. Master Bed) and Small (Bath).\n      // Carve 25-30% of space for the Bath.\n      const isWide = rect.w > rect.h;\n\n      // Calculate split\n      const smallRatio = 0.35; // 35% for bath\n      let bigRect, smallRect;\n      if (isWide) {\n        // Split Vertically (Side by Side)\n        const wSmall = rect.w * smallRatio;\n        bigRect = new Rect(rect.x, rect.y, rect.w - wSmall, rect.h);\n        smallRect = new Rect(rect.x + (rect.w - wSmall), rect.y, wSmall, rect.h);\n      } else {\n        // Split Horizontally (Top/Bottom) - usually Bath is at \"top\" (back of house)\n        const hSmall = rect.h * smallRatio;\n        // In our coordinate system, y=0 is \"Back\". So if this is a rear room, bath goes to y.\n        // If front room, bath goes to y+h.\n        // Simplified: Bath always \"above\" (visually in plan) or \"below\".\n        smallRect = new Rect(rect.x, rect.y, rect.w, hSmall);\n        bigRect = new Rect(rect.x, rect.y + hSmall, rect.w, rect.h - hSmall);\n      }\n      regions.push({\n        ...bigRect,\n        type: bigs[0]\n      });\n\n      // If multiple smalls, split the smallRect\n      if (smalls.length > 1) {\n        const subH = smallRect.h / smalls.length;\n        smalls.forEach((s, i) => {\n          regions.push({\n            x: smallRect.x,\n            y: smallRect.y + i * subH,\n            w: smallRect.w,\n            h: subH,\n            type: s\n          });\n        });\n      } else {\n        regions.push({\n          ...smallRect,\n          type: smalls[0]\n        });\n      }\n    };\n\n    // EXECUTE\n    // Sort items so \"Rear\" items (Kitchen, Master) are processed first (y=0)\n    // We want Kitchen at Top of plan (Back of house).\n    // Our Recursive Solver fills top-down or left-right.\n    // So we put Kitchen/Master at start of array.\n\n    // Sort Heuristic:\n    const sortScore = c => {\n      const t = c.rooms.join('');\n      if (t.includes('kitchen') || t.includes('master')) return 0;\n      if (t.includes('living') || t.includes('garage')) return 10;\n      return 5;\n    };\n    leftItems.sort((a, b) => sortScore(a) - sortScore(b));\n    rightItems.sort((a, b) => sortScore(a) - sortScore(b));\n    solveSpace(leftWing, leftItems);\n    solveSpace(rightWing, rightItems);\n    allFloorsRegions.push(regions);\n  });\n  blackboard.write('floorRegions', allFloorsRegions);\n  return true;\n};\n\n// --- AGENT 3: STRUCTURAL AGENT (Walls) ---\n_c3 = LayoutAgent;\nconst StructuralAgent = async () => {\n  LOG('Generating Walls...');\n  const floorRegions = blackboard.read('floorRegions');\n  const allWalls = [];\n  floorRegions.forEach(rooms => {\n    const walls = [];\n    rooms.forEach(r => {\n      // Standard Box Walls\n      // Optimization: We could merge collinear walls here, but for this level of visual, individual segments are fine.\n      walls.push({\n        x1: r.x,\n        y1: r.y,\n        x2: r.x + r.w,\n        y2: r.y,\n        type: 'inner'\n      }); // Top\n      walls.push({\n        x1: r.x,\n        y1: r.y + r.h,\n        x2: r.x + r.w,\n        y2: r.y + r.h,\n        type: 'inner'\n      }); // Bottom\n      walls.push({\n        x1: r.x,\n        y1: r.y,\n        x2: r.x,\n        y2: r.y + r.h,\n        type: 'inner'\n      }); // Left\n      walls.push({\n        x1: r.x + r.w,\n        y1: r.y,\n        x2: r.x + r.w,\n        y2: r.y + r.h,\n        type: 'inner'\n      }); // Right\n    });\n\n    // Outer Shell\n    const b = blackboard.read('siteBoundary');\n    const outer = [{\n      x1: b.x,\n      y1: b.y,\n      x2: b.x + b.w,\n      y2: b.y\n    }, {\n      x1: b.x,\n      y1: b.y + b.h,\n      x2: b.x + b.w,\n      y2: b.y + b.h\n    }, {\n      x1: b.x,\n      y1: b.y,\n      x2: b.x,\n      y2: b.y + b.h\n    }, {\n      x1: b.x + b.w,\n      y1: b.y,\n      x2: b.x + b.w,\n      y2: b.y + b.h\n    }];\n    allWalls.push({\n      inner: walls,\n      outer: outer\n    });\n  });\n  blackboard.write('floorWalls', allWalls);\n  return true;\n};\n\n// --- AGENT 4: CONNECTIVITY AGENT (Smart Doors) ---\n_c4 = StructuralAgent;\nconst ConnectivityAgent = async () => {\n  LOG('Calculating Doors based on Adjacency Graph...');\n  const floorRegions = blackboard.read('floorRegions');\n  const allDoors = [];\n  floorRegions.forEach((rooms, floorIndex) => {\n    const doors = [];\n    const addUniqueDoor = d => {\n      // Avoid duplicate doors on the same wall\n      if (!doors.some(ex => Math.abs(ex.x - d.x) < 2 && Math.abs(ex.y - d.y) < 2)) {\n        doors.push(d);\n      }\n    };\n\n    // Iterate all pairs\n    for (let i = 0; i < rooms.length; i++) {\n      for (let j = i + 1; j < rooms.length; j++) {\n        const r1 = rooms[i];\n        const r2 = rooms[j];\n\n        // Geometric Checks\n        const touchY = Math.abs(r1.y + r1.h - r2.y) < 0.1 || Math.abs(r2.y + r2.h - r1.y) < 0.1;\n        const touchX = Math.abs(r1.x + r1.w - r2.x) < 0.1 || Math.abs(r2.x + r2.w - r1.x) < 0.1;\n        const overlapX = Math.min(r1.x + r1.w, r2.x + r2.w) - Math.max(r1.x, r2.x);\n        const overlapY = Math.min(r1.y + r1.h, r2.y + r2.h) - Math.max(r1.y, r2.y);\n\n        // Logic Checks: Should these rooms connect?\n        const isHall = r1.type === 'hallway' || r2.type === 'hallway';\n\n        // Ensuite Logic: Bath connects to Bed, but NOT to Hall (unless guest bath)\n        const r1Bath = r1.type === 'bathroom';\n        const r2Bath = r2.type === 'bathroom';\n        const r1Bed = r1.type.includes('bed');\n        const r2Bed = r2.type.includes('bed');\n        let shouldConnect = false;\n        if (isHall) {\n          // Hall connects to everything EXCEPT ensuite baths\n          // If r1 is hall, r2 is room.\n          const roomType = r1.type === 'hallway' ? r2.type : r1.type;\n          // If room is bathroom, only connect if it's the \"Guest\" bath (how to tell? heuristics)\n          // For now, we connect hall to bath ONLY if that bath isn't touching a bedroom? \n          // Simpler: Hall connects to everything. Privacy agent would lock doors.\n          shouldConnect = true;\n        }\n        if (r1Bath && r2Bed || r2Bath && r1Bed) {\n          // Ensuite connection!\n          shouldConnect = true;\n        }\n\n        // Dining <-> Kitchen\n        if (r1.type === 'kitchen' && r2.type === 'dining' || r2.type === 'kitchen' && r1.type === 'dining') {\n          shouldConnect = true;\n        }\n\n        // Living <-> Dining (Open plan feel)\n        if (r1.type === 'living' && r2.type === 'dining' || r2.type === 'living' && r1.type === 'dining') {\n          shouldConnect = true;\n        }\n        if (shouldConnect) {\n          if (touchY && overlapX > 3) {\n            const mid = Math.max(r1.x, r2.x) + overlapX / 2;\n            addUniqueDoor({\n              x: mid - 1.5,\n              y: r1.y < r2.y ? r2.y : r1.y,\n              w: 3,\n              vertical: false\n            });\n          } else if (touchX && overlapY > 3) {\n            const mid = Math.max(r1.y, r2.y) + overlapY / 2;\n            addUniqueDoor({\n              x: r1.x < r2.x ? r2.x : r1.x,\n              y: mid - 1.5,\n              w: 3,\n              vertical: true\n            });\n          }\n        }\n      }\n    }\n\n    // Front Door\n    if (floorIndex === 0) {\n      const hall = rooms.find(r => r.type === 'hallway');\n      if (hall) addUniqueDoor({\n        x: hall.x + hall.w / 2 - 2,\n        y: hall.y + hall.h,\n        w: 4,\n        vertical: false,\n        type: 'main'\n      });\n    }\n    allDoors.push(doors);\n  });\n  blackboard.write('floorDoors', allDoors);\n  return true;\n};\n\n// --- EXPORT ---\n_c5 = ConnectivityAgent;\nexport const agents = [{\n  name: 'Zoning & Clustering',\n  fn: ZoningAgent\n}, {\n  name: 'Constraint Solver',\n  fn: LayoutAgent\n}, {\n  name: 'Structural Skeleton',\n  fn: StructuralAgent\n}, {\n  name: 'Connectivity Graph',\n  fn: ConnectivityAgent\n}];\nvar _c, _c2, _c3, _c4, _c5;\n$RefreshReg$(_c, \"LOG\");\n$RefreshReg$(_c2, \"ZoningAgent\");\n$RefreshReg$(_c3, \"LayoutAgent\");\n$RefreshReg$(_c4, \"StructuralAgent\");\n$RefreshReg$(_c5, \"ConnectivityAgent\");","map":{"version":3,"names":["blackboard","LOG","msg","console","log","_c","ROOM_SPECS","minDim","maxDim","idealRatio","priority","color","ADJACENCY_RULES","r1","r2","score","Rect","constructor","x","y","w","h","area","ratio","right","bottom","intersects","other","contains","splitVert","w1","splitHorz","h1","ZoningAgent","config","pad","buildW","width","buildD","depth","write","inventory","rooms","floorPlans","Array","from","length","floors","clusters","singles","assign","floorIdx","item","type","f","Math","min","push","bedroom","hasBath","bathroom","roomsInSuite","targetFloor","id","currentFloor","roomsInCluster","serviceRooms","kitchen","dining","utility","store","groundPriority","forEach","r","Object","keys","k","_c2","LayoutAgent","site","read","allFloorsRegions","SPINE_WIDTH","plan","regions","spineX","hallRect","stairRect","leftWing","rightWing","leftItems","rightItems","cluster","types","join","includes","solveSpace","space","solveCluster","isTall","mid","ceil","group1","slice","group2","reduce","acc","c","w2","total","splitRatio","rect","smalls","filter","bigs","subH","i","isWide","smallRatio","bigRect","smallRect","wSmall","hSmall","s","sortScore","t","sort","a","b","_c3","StructuralAgent","floorRegions","allWalls","walls","x1","y1","x2","y2","outer","inner","_c4","ConnectivityAgent","allDoors","floorIndex","doors","addUniqueDoor","d","some","ex","abs","j","touchY","touchX","overlapX","max","overlapY","isHall","r1Bath","r2Bath","r1Bed","r2Bed","shouldConnect","roomType","vertical","hall","find","_c5","agents","name","fn","$RefreshReg$"],"sources":["E:/PAP/SEM 5  (Current)/Agent Based Software Engineering (ABSE)/Schematic-Architecture-Generator/ShamArchitectSys_Final/src/agents/AgentSystem.js"],"sourcesContent":["import { blackboard } from '../core/Blackboard';\n\n/**\n * ==================================================================================\n * SHAM ARCHITECT SYS - PRO GEN 5.0 (THE \"ULTIMATE\" SOLVER)\n * ==================================================================================\n * * ARCHITECTURE:\n * 1. KNOWLEDGE BASE: Defines strict rules (Min dimensions, adjacency scores).\n * 2. GEOMETRY ENGINE: Handles 2D boolean operations, collision, and alignment.\n * 3. AGENTS:\n * - ZONING AGENT: Assigns rooms to floors and \"Privacy Clusters\".\n * - TOPOLOGY AGENT: Defines the ideal \"Graph\" (Room A must touch Room B).\n * - LAYOUT SOLVER: A Monte-Carlo-lite solver that attempts to pack rooms \n * into the shell while minimizing a \"Badness Cost\".\n * - STRUCTURAL AGENT: Generates walls based on the final solved regions.\n */\n\nconst LOG = (msg) => console.log(`[Architect Core] ${msg}`);\n\n// ==================================================================================\n// 1. ARCHITECTURAL KNOWLEDGE BASE (The Rules)\n// ==================================================================================\n\nconst ROOM_SPECS = {\n  // PUBLIC ZONES\n  'living':     { minDim: 12, maxDim: 22, idealRatio: 1.3, priority: 10, color: '#fff7ed' },\n  'dining':     { minDim: 10, maxDim: 16, idealRatio: 1.2, priority: 8,  color: '#fffbeb' },\n  'garage':     { minDim: 12, maxDim: 24, idealRatio: 1.1, priority: 9,  color: '#f1f5f9' },\n  'kitchen':    { minDim: 10, maxDim: 18, idealRatio: 1.4, priority: 9,  color: '#ecfeff' },\n  \n  // PRIVATE ZONES\n  'master-bed': { minDim: 13, maxDim: 18, idealRatio: 1.1, priority: 10, color: '#f0f9ff' },\n  'bedroom':    { minDim: 10, maxDim: 14, idealRatio: 1.0, priority: 8,  color: '#f0f9ff' },\n  'study':      { minDim: 8,  maxDim: 12, idealRatio: 1.0, priority: 5,  color: '#fefce8' },\n  'library':    { minDim: 10, maxDim: 14, idealRatio: 1.2, priority: 6,  color: '#fefce8' },\n  \n  // SERVICE / WET ZONES (The \"Parasitic\" Rooms)\n  'bathroom':   { minDim: 5,  maxDim: 10, idealRatio: 1.2, priority: 7,  color: '#f8fafc' },\n  'utility':    { minDim: 6,  maxDim: 10, idealRatio: 1.5, priority: 4,  color: '#f3f4f6' },\n  'store':      { minDim: 4,  maxDim: 8,  idealRatio: 1.0, priority: 3,  color: '#cbd5e1' },\n  'prayer':     { minDim: 6,  maxDim: 10, idealRatio: 1.0, priority: 5,  color: '#f0fdf4' },\n  \n  // CIRCULATION\n  'hallway':    { minDim: 4,  maxDim: 8,  idealRatio: 4.0, priority: 1,  color: '#ffffff' },\n  'stairs':     { minDim: 8,  maxDim: 12, idealRatio: 1.0, priority: 10, color: '#e2e8f0' }\n};\n\nconst ADJACENCY_RULES = [\n  // High Priority Constraints\n  { r1: 'kitchen', r2: 'dining', score: 100 },\n  { r1: 'master-bed', r2: 'bathroom', score: 90 }, // Ensuite\n  { r1: 'living', r2: 'dining', score: 50 },\n  { r1: 'garage', r2: 'utility', score: 40 },\n  { r1: 'kitchen', r2: 'utility', score: 40 },\n];\n\n// ==================================================================================\n// 2. GEOMETRY ENGINE (Helper Class)\n// ==================================================================================\n\nclass Rect {\n  constructor(x, y, w, h) {\n    this.x = x; this.y = y; this.w = w; this.h = h;\n  }\n  \n  get area() { return this.w * this.h; }\n  get ratio() { return this.w > this.h ? this.w/this.h : this.h/this.w; }\n  get right() { return this.x + this.w; }\n  get bottom() { return this.y + this.h; }\n  \n  // Returns true if this rect overlaps or touches another\n  intersects(other) {\n    return !(this.right <= other.x || this.x >= other.right || this.bottom <= other.y || this.y >= other.bottom);\n  }\n\n  // Returns true if this rect strictly contains another\n  contains(other) {\n    return (this.x <= other.x && this.right >= other.right && this.y <= other.y && this.bottom >= other.bottom);\n  }\n  \n  // Slice operations\n  splitVert(ratio) { // Split at X\n    const w1 = this.w * ratio;\n    return [\n      new Rect(this.x, this.y, w1, this.h),\n      new Rect(this.x + w1, this.y, this.w - w1, this.h)\n    ];\n  }\n  \n  splitHorz(ratio) { // Split at Y\n    const h1 = this.h * ratio;\n    return [\n      new Rect(this.x, this.y, this.w, h1),\n      new Rect(this.x, this.y + h1, this.w, this.h - h1)\n    ];\n  }\n}\n\n// ==================================================================================\n// 3. AGENT IMPLEMENTATIONS\n// ==================================================================================\n\n// --- AGENT 1: ZONING & INVENTORY ---\n// Responsible for deciding WHAT goes on WHICH floor and creating \"Clusters\".\n// e.g. \"Master Bed\" + \"Master Bath\" becomes a single logical unit \"Master Suite\".\n\nconst ZoningAgent = async (config) => {\n  LOG('Parsing inventory and creating logical clusters...');\n  \n  const pad = 4;\n  const buildW = config.width - (pad*2);\n  const buildD = config.depth - (pad*2);\n  \n  blackboard.write('siteBoundary', new Rect(pad, pad, buildW, buildD));\n  \n  // 1. Clone Inventory\n  const inventory = { ...config.rooms };\n  const floorPlans = Array.from({ length: config.floors }, () => ({\n    clusters: [], // A cluster is { name: 'Master Suite', rooms: ['master-bed', 'bathroom'], priority: 10 }\n    singles: []   // Loose rooms like 'living'\n  }));\n\n  // 2. Helper to assign to floor\n  const assign = (floorIdx, item, type = 'single') => {\n    const f = Math.min(floorIdx, config.floors - 1);\n    if(type === 'cluster') floorPlans[f].clusters.push(item);\n    else floorPlans[f].singles.push(item);\n  };\n\n  // 3. Logic: Create Master Suite (Always tries to pair a bath with master)\n  if (inventory.bedroom > 0) {\n    // Check if we can make a suite\n    const hasBath = inventory.bathroom > 0;\n    const roomsInSuite = ['master-bed'];\n    inventory.bedroom--;\n    \n    if (hasBath) {\n      roomsInSuite.push('bathroom');\n      inventory.bathroom--;\n    }\n    \n    // Assign Master Suite to highest priority floor (First floor if exists, else Ground)\n    const targetFloor = config.floors > 1 ? 1 : 0;\n    assign(targetFloor, { type: 'SUITE', rooms: roomsInSuite, id: 'master-suite' }, 'cluster');\n  }\n\n  // 4. Create Standard Bedroom Clusters (Bed + Bath if available)\n  // We try to pair bathrooms to bedrooms to avoid \"floating\" bathrooms\n  let currentFloor = config.floors > 1 ? 1 : 0;\n  \n  while(inventory.bedroom > 0) {\n    const roomsInCluster = ['bedroom'];\n    inventory.bedroom--;\n    \n    // 50% chance to grab a bath if we have plenty, or if it's the only bed left\n    if (inventory.bathroom > 0) {\n      roomsInCluster.push('bathroom');\n      inventory.bathroom--;\n    }\n    \n    assign(currentFloor, { type: 'BED-CLUSTER', rooms: roomsInCluster, id: `bed-cluster-${inventory.bedroom}` }, 'cluster');\n    \n    // Rotate floors\n    if (config.floors > 2 && currentFloor < config.floors - 1) currentFloor++;\n    else if (config.floors > 1) currentFloor = 1;\n  }\n\n  // 5. Ground Floor Service Cluster (Kitchen + Dining + Utility)\n  // We group them so they stay together\n  const serviceRooms = [];\n  if (inventory.kitchen > 0) { serviceRooms.push('kitchen'); inventory.kitchen--; }\n  if (inventory.dining > 0) { serviceRooms.push('dining'); inventory.dining--; }\n  if (inventory.utility > 0) { serviceRooms.push('utility'); inventory.utility--; }\n  if (inventory.store > 0) { serviceRooms.push('store'); inventory.store--; }\n  \n  if (serviceRooms.length > 0) {\n    assign(0, { type: 'SERVICE-CORE', rooms: serviceRooms, id: 'service-core' }, 'cluster');\n  }\n\n  // 6. Remaining Rooms (Living, Garage, Prayer, Floating Baths)\n  const groundPriority = ['garage', 'living', 'prayer', 'bathroom']; // Bath here is guest bath\n  \n  groundPriority.forEach(r => {\n    while(inventory[r] > 0) {\n      assign(0, { type: 'SINGLE', rooms: [r], id: `${r}-gen` }, 'cluster');\n      inventory[r]--;\n    }\n  });\n\n  // Dump anything else (Library etc)\n  Object.keys(inventory).forEach(k => {\n    while(inventory[k] > 0) {\n      const f = (k === 'library' || k === 'study') ? (config.floors > 1 ? 1 : 0) : 0;\n      assign(f, { type: 'SINGLE', rooms: [k], id: `${k}-misc` }, 'cluster');\n      inventory[k]--;\n    }\n  });\n\n  blackboard.write('floorPlans', floorPlans);\n  return true;\n};\n\n// --- AGENT 2: LAYOUT SOLVER (The Heavy Lifter) ---\n// Uses a recursive slicing algorithm with \"Aspect Ratio Protection\".\n// Unlike the old version, this explicitly checks if a split would result in a skinny room.\n\nconst LayoutAgent = async () => {\n  LOG('Solving geometry with Aspect Ratio Constraints...');\n  \n  const site = blackboard.read('siteBoundary');\n  const floorPlans = blackboard.read('floorPlans');\n  const config = blackboard.read('config');\n  const allFloorsRegions = [];\n\n  // CONSTANTS for the solver\n  const SPINE_WIDTH = 6;\n  \n  floorPlans.forEach((plan, floorIdx) => {\n    const regions = [];\n    \n    // 1. Setup the Bounds\n    // Define the central hallway spine immediately. This is the anchor.\n    // X Position: Center\n    const spineX = site.x + (site.w - SPINE_WIDTH) / 2;\n    const hallRect = new Rect(spineX, site.y + 6, SPINE_WIDTH, site.h - 10);\n    regions.push({ ...hallRect, type: 'hallway', id: 'main-spine' });\n    \n    if (config.floors > 1) {\n      // Place stairs at the back of the hallway\n      const stairRect = new Rect(spineX, hallRect.bottom - 10, SPINE_WIDTH, 10);\n      regions.push({ ...stairRect, type: 'stairs', id: 'stairs' });\n      // Shorten hall visually to not overlap stairs\n      hallRect.h -= 10; \n    }\n\n    // 2. We now have two massive empty spaces: LEFT WING and RIGHT WING\n    const leftWing = new Rect(site.x, site.y, (site.w - SPINE_WIDTH)/2, site.h);\n    const rightWing = new Rect(spineX + SPINE_WIDTH, site.y, (site.w - SPINE_WIDTH)/2, site.h);\n\n    // 3. Sort Clusters into Wings\n    // Heuristic: \n    // - Garage/Kitchen/Service -> RIGHT WING (Functional)\n    // - Living/Bedrooms -> LEFT WING (Living)\n    // - Master Suite -> Rear Right (Privacy)\n    \n    const leftItems = [];\n    const rightItems = [];\n\n    plan.clusters.forEach(cluster => {\n      const types = cluster.rooms.join(',');\n      \n      // Force assignments\n      if (types.includes('garage')) rightItems.push(cluster);\n      else if (types.includes('kitchen')) rightItems.push(cluster);\n      else if (types.includes('utility')) rightItems.push(cluster);\n      else if (types.includes('living')) leftItems.push(cluster);\n      else if (types.includes('master')) rightItems.push(cluster); // Master on right rear usually nice\n      else if (types.includes('bedroom')) leftItems.push(cluster);\n      else {\n        // Balance\n        if (leftItems.length <= rightItems.length) leftItems.push(cluster);\n        else rightItems.push(cluster);\n      }\n    });\n\n    // 4. THE RECURSIVE SOLVER\n    // This function takes a Rect and a list of Clusters.\n    // It subdivides the rect to fit the clusters while respecting ratios.\n    \n    const solveSpace = (space, clusters) => {\n      if (clusters.length === 0) return;\n      \n      // Base Case: 1 Cluster\n      if (clusters.length === 1) {\n        // We have one cluster (e.g. Master Suite [Bed, Bath]) to fit in 'space'.\n        // We need to subdivide 'space' internally for the rooms in the cluster.\n        solveCluster(space, clusters[0]);\n        return;\n      }\n\n      // Recursive Step: Split the space\n      // Decide split direction based on aspect ratio of the space\n      // If Space is Tall -> Split Horizontally\n      // If Space is Wide -> Split Vertically\n      const isTall = space.h > space.w;\n      \n      // We divide the list of clusters into two groups\n      const mid = Math.ceil(clusters.length / 2);\n      const group1 = clusters.slice(0, mid);\n      const group2 = clusters.slice(mid);\n      \n      // Calculate weight of each group (heuristic: count of rooms)\n      const w1 = group1.reduce((acc, c) => acc + c.rooms.length, 0);\n      const w2 = group2.reduce((acc, c) => acc + c.rooms.length, 0);\n      const total = w1 + w2;\n      const splitRatio = w1 / total;\n\n      let r1, r2;\n      \n      if (isTall) {\n        // Horizontal Cut\n        [r1, r2] = space.splitHorz(splitRatio);\n      } else {\n        // Vertical Cut\n        [r1, r2] = space.splitVert(splitRatio);\n      }\n\n      solveSpace(r1, group1);\n      solveSpace(r2, group2);\n    };\n\n    // 5. CLUSTER SOLVER (The \"Parasitic\" Logic)\n    // Fits [Master Bed, Bath] into a specific rect\n    const solveCluster = (rect, cluster) => {\n      const rooms = cluster.rooms; // e.g. ['master-bed', 'bathroom']\n      \n      if (rooms.length === 1) {\n        regions.push({ ...rect, type: rooms[0], id: cluster.id });\n        return;\n      }\n\n      // We have multiple rooms. We need to identify the \"Main\" room and the \"Parasites\".\n      // Big rooms: Living, Bed, Kitchen\n      // Small rooms: Bath, Utility, Store\n      \n      const smalls = rooms.filter(r => ['bathroom','utility','store','prayer'].includes(r));\n      const bigs = rooms.filter(r => !['bathroom','utility','store','prayer'].includes(r));\n\n      // Strategy: Carve out space for smalls from the rect, give rest to bigs.\n      // Usually carve a strip from the \"back\" or \"side\".\n      \n      if (bigs.length === 0) { \n        // All smalls (e.g. Utility + Store). Just split evenly.\n         const subH = rect.h / rooms.length;\n         rooms.forEach((r, i) => {\n            regions.push({ x: rect.x, y: rect.y + (i*subH), w: rect.w, h: subH, type: r });\n         });\n         return;\n      }\n      \n      // We have a Big Room (e.g. Master Bed) and Small (Bath).\n      // Carve 25-30% of space for the Bath.\n      const isWide = rect.w > rect.h;\n      \n      // Calculate split\n      const smallRatio = 0.35; // 35% for bath\n      let bigRect, smallRect;\n      \n      if (isWide) {\n        // Split Vertically (Side by Side)\n        const wSmall = rect.w * smallRatio;\n        bigRect = new Rect(rect.x, rect.y, rect.w - wSmall, rect.h);\n        smallRect = new Rect(rect.x + (rect.w - wSmall), rect.y, wSmall, rect.h);\n      } else {\n        // Split Horizontally (Top/Bottom) - usually Bath is at \"top\" (back of house)\n        const hSmall = rect.h * smallRatio;\n        // In our coordinate system, y=0 is \"Back\". So if this is a rear room, bath goes to y.\n        // If front room, bath goes to y+h.\n        // Simplified: Bath always \"above\" (visually in plan) or \"below\".\n        smallRect = new Rect(rect.x, rect.y, rect.w, hSmall);\n        bigRect = new Rect(rect.x, rect.y + hSmall, rect.w, rect.h - hSmall);\n      }\n\n      regions.push({ ...bigRect, type: bigs[0] });\n      \n      // If multiple smalls, split the smallRect\n      if (smalls.length > 1) {\n         const subH = smallRect.h / smalls.length;\n         smalls.forEach((s, i) => {\n            regions.push({ x: smallRect.x, y: smallRect.y + (i*subH), w: smallRect.w, h: subH, type: s });\n         });\n      } else {\n         regions.push({ ...smallRect, type: smalls[0] });\n      }\n    };\n\n    // EXECUTE\n    // Sort items so \"Rear\" items (Kitchen, Master) are processed first (y=0)\n    // We want Kitchen at Top of plan (Back of house).\n    // Our Recursive Solver fills top-down or left-right.\n    // So we put Kitchen/Master at start of array.\n    \n    // Sort Heuristic:\n    const sortScore = (c) => {\n      const t = c.rooms.join('');\n      if(t.includes('kitchen') || t.includes('master')) return 0;\n      if(t.includes('living') || t.includes('garage')) return 10;\n      return 5;\n    };\n    \n    leftItems.sort((a,b) => sortScore(a) - sortScore(b));\n    rightItems.sort((a,b) => sortScore(a) - sortScore(b));\n\n    solveSpace(leftWing, leftItems);\n    solveSpace(rightWing, rightItems);\n    \n    allFloorsRegions.push(regions);\n  });\n\n  blackboard.write('floorRegions', allFloorsRegions);\n  return true;\n};\n\n// --- AGENT 3: STRUCTURAL AGENT (Walls) ---\nconst StructuralAgent = async () => {\n  LOG('Generating Walls...');\n  const floorRegions = blackboard.read('floorRegions');\n  const allWalls = [];\n\n  floorRegions.forEach((rooms) => {\n    const walls = [];\n    rooms.forEach(r => {\n      // Standard Box Walls\n      // Optimization: We could merge collinear walls here, but for this level of visual, individual segments are fine.\n      walls.push({ x1: r.x, y1: r.y, x2: r.x+r.w, y2: r.y, type: 'inner' }); // Top\n      walls.push({ x1: r.x, y1: r.y+r.h, x2: r.x+r.w, y2: r.y+r.h, type: 'inner' }); // Bottom\n      walls.push({ x1: r.x, y1: r.y, x2: r.x, y2: r.y+r.h, type: 'inner' }); // Left\n      walls.push({ x1: r.x+r.w, y1: r.y, x2: r.x+r.w, y2: r.y+r.h, type: 'inner' }); // Right\n    });\n    \n    // Outer Shell\n    const b = blackboard.read('siteBoundary');\n    const outer = [\n      { x1: b.x, y1: b.y, x2: b.x+b.w, y2: b.y },\n      { x1: b.x, y1: b.y+b.h, x2: b.x+b.w, y2: b.y+b.h },\n      { x1: b.x, y1: b.y, x2: b.x, y2: b.y+b.h },\n      { x1: b.x+b.w, y1: b.y, x2: b.x+b.w, y2: b.y+b.h },\n    ];\n    allWalls.push({ inner: walls, outer: outer });\n  });\n\n  blackboard.write('floorWalls', allWalls);\n  return true;\n};\n\n// --- AGENT 4: CONNECTIVITY AGENT (Smart Doors) ---\nconst ConnectivityAgent = async () => {\n  LOG('Calculating Doors based on Adjacency Graph...');\n  const floorRegions = blackboard.read('floorRegions');\n  const allDoors = [];\n\n  floorRegions.forEach((rooms, floorIndex) => {\n    const doors = [];\n    \n    const addUniqueDoor = (d) => {\n      // Avoid duplicate doors on the same wall\n      if(!doors.some(ex => Math.abs(ex.x - d.x) < 2 && Math.abs(ex.y - d.y) < 2)) {\n        doors.push(d);\n      }\n    };\n\n    // Iterate all pairs\n    for (let i = 0; i < rooms.length; i++) {\n      for (let j = i + 1; j < rooms.length; j++) {\n        const r1 = rooms[i];\n        const r2 = rooms[j];\n        \n        // Geometric Checks\n        const touchY = Math.abs(r1.y + r1.h - r2.y) < 0.1 || Math.abs(r2.y + r2.h - r1.y) < 0.1;\n        const touchX = Math.abs(r1.x + r1.w - r2.x) < 0.1 || Math.abs(r2.x + r2.w - r1.x) < 0.1;\n        \n        const overlapX = (Math.min(r1.x+r1.w, r2.x+r2.w) - Math.max(r1.x, r2.x));\n        const overlapY = (Math.min(r1.y+r1.h, r2.y+r2.h) - Math.max(r1.y, r2.y));\n        \n        // Logic Checks: Should these rooms connect?\n        const isHall = r1.type === 'hallway' || r2.type === 'hallway';\n        \n        // Ensuite Logic: Bath connects to Bed, but NOT to Hall (unless guest bath)\n        const r1Bath = r1.type === 'bathroom';\n        const r2Bath = r2.type === 'bathroom';\n        const r1Bed = r1.type.includes('bed');\n        const r2Bed = r2.type.includes('bed');\n        \n        let shouldConnect = false;\n        \n        if (isHall) {\n           // Hall connects to everything EXCEPT ensuite baths\n           // If r1 is hall, r2 is room.\n           const roomType = r1.type === 'hallway' ? r2.type : r1.type;\n           // If room is bathroom, only connect if it's the \"Guest\" bath (how to tell? heuristics)\n           // For now, we connect hall to bath ONLY if that bath isn't touching a bedroom? \n           // Simpler: Hall connects to everything. Privacy agent would lock doors.\n           shouldConnect = true; \n        }\n        \n        if ((r1Bath && r2Bed) || (r2Bath && r1Bed)) {\n           // Ensuite connection!\n           shouldConnect = true; \n        }\n        \n        // Dining <-> Kitchen\n        if ((r1.type==='kitchen' && r2.type==='dining') || (r2.type==='kitchen' && r1.type==='dining')) {\n           shouldConnect = true; \n        }\n\n        // Living <-> Dining (Open plan feel)\n        if ((r1.type==='living' && r2.type==='dining') || (r2.type==='living' && r1.type==='dining')) {\n           shouldConnect = true; \n        }\n\n        if (shouldConnect) {\n           if (touchY && overlapX > 3) {\n             const mid = Math.max(r1.x, r2.x) + (overlapX/2);\n             addUniqueDoor({ x: mid - 1.5, y: (r1.y < r2.y ? r2.y : r1.y), w: 3, vertical: false });\n           } else if (touchX && overlapY > 3) {\n             const mid = Math.max(r1.y, r2.y) + (overlapY/2);\n             addUniqueDoor({ x: (r1.x < r2.x ? r2.x : r1.x), y: mid - 1.5, w: 3, vertical: true });\n           }\n        }\n      }\n    }\n    \n    // Front Door\n    if (floorIndex === 0) {\n      const hall = rooms.find(r => r.type === 'hallway');\n      if (hall) addUniqueDoor({ x: hall.x + hall.w/2 - 2, y: hall.y + hall.h, w: 4, vertical: false, type: 'main' });\n    }\n\n    allDoors.push(doors);\n  });\n\n  blackboard.write('floorDoors', allDoors);\n  return true;\n};\n\n// --- EXPORT ---\nexport const agents = [\n  { name: 'Zoning & Clustering', fn: ZoningAgent },\n  { name: 'Constraint Solver', fn: LayoutAgent },\n  { name: 'Structural Skeleton', fn: StructuralAgent },\n  { name: 'Connectivity Graph', fn: ConnectivityAgent },\n];"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}