{"ast":null,"code":"import { blackboard } from '../core/Blackboard';\n\n/**\n * ==================================================================================\n * SHAM ARCHITECT SYS - PRO GEN 6.0 (DIRECT ACCESS SOLVER)\n * ==================================================================================\n * Key Feature: \"Spine-Anchored Layout\"\n * Ensures every primary room touches the central hallway.\n */\n\nconst LOG = msg => console.log(`[Architect Core] ${msg}`);\n\n// ==================================================================================\n// 1. ARCHITECTURAL KNOWLEDGE BASE\n// ==================================================================================\n_c = LOG;\nconst ROOM_SPECS = {\n  // Weights determine relative height/size of the room in the stack\n  'living': {\n    weight: 2.2,\n    minDim: 14,\n    color: '#fff7ed',\n    label: 'Living Room'\n  },\n  'dining': {\n    weight: 1.4,\n    minDim: 11,\n    color: '#fffbeb',\n    label: 'Dining'\n  },\n  'garage': {\n    weight: 2.0,\n    minDim: 12,\n    color: '#f1f5f9',\n    label: 'Garage'\n  },\n  'kitchen': {\n    weight: 1.5,\n    minDim: 11,\n    color: '#ecfeff',\n    label: 'Kitchen'\n  },\n  'master-bed': {\n    weight: 1.8,\n    minDim: 13,\n    color: '#f0f9ff',\n    label: 'Master Suite'\n  },\n  'bedroom': {\n    weight: 1.3,\n    minDim: 10,\n    color: '#f0f9ff',\n    label: 'Bedroom'\n  },\n  'study': {\n    weight: 1.0,\n    minDim: 9,\n    color: '#fefce8',\n    label: 'Study'\n  },\n  'library': {\n    weight: 1.2,\n    minDim: 10,\n    color: '#fefce8',\n    label: 'Library'\n  },\n  'bathroom': {\n    weight: 0.8,\n    minDim: 6,\n    color: '#f8fafc',\n    label: 'Bath'\n  },\n  // Independent Bath\n  'utility': {\n    weight: 0.9,\n    minDim: 7,\n    color: '#f3f4f6',\n    label: 'Laundry'\n  },\n  'prayer': {\n    weight: 0.8,\n    minDim: 7,\n    color: '#f0fdf4',\n    label: 'Prayer'\n  },\n  'store': {\n    weight: 0.5,\n    minDim: 5,\n    color: '#cbd5e1',\n    label: 'Store'\n  },\n  // Circulation\n  'hallway': {\n    weight: 0,\n    minDim: 4,\n    color: '#ffffff',\n    label: 'Hallway'\n  },\n  'stairs': {\n    weight: 0,\n    minDim: 8,\n    color: '#e2e8f0',\n    label: 'Stairs'\n  }\n};\n\n// ==================================================================================\n// 2. GEOMETRY ENGINE\n// ==================================================================================\n\nclass Rect {\n  constructor(x, y, w, h) {\n    this.x = x;\n    this.y = y;\n    this.w = w;\n    this.h = h;\n  }\n  get right() {\n    return this.x + this.w;\n  }\n  get bottom() {\n    return this.y + this.h;\n  }\n}\n\n// ==================================================================================\n// 3. AGENT IMPLEMENTATIONS\n// ==================================================================================\n\n// --- AGENT 1: ZONING (Assigns Logic) ---\nconst ZoningAgent = async config => {\n  LOG('Zoning rooms with direct-access priority...');\n  const pad = 4;\n  const buildW = config.width - pad * 2;\n  const buildD = config.depth - pad * 2;\n  blackboard.write('siteBoundary', new Rect(pad, pad, buildW, buildD));\n  const inventory = {\n    ...config.rooms\n  };\n  const floorPlans = Array.from({\n    length: config.floors\n  }, () => ({\n    clusters: []\n  }));\n  const assign = (fIdx, cluster) => {\n    const f = Math.min(fIdx, config.floors - 1);\n    floorPlans[f].clusters.push(cluster);\n  };\n\n  // --- CLUSTER LOGIC ---\n  // A \"Cluster\" is a row in the stack. \n  // It can be a Single Room (Direct Access) or a Suite (Master + Ensuite).\n\n  // 1. Master Suite (Priority 1)\n  if (inventory.bedroom > 0) {\n    const cluster = {\n      type: 'SUITE',\n      main: 'master-bed',\n      subs: [],\n      id: 'master'\n    };\n    inventory.bedroom--;\n    if (inventory.bathroom > 0) {\n      cluster.subs.push('bathroom');\n      inventory.bathroom--;\n    }\n    assign(config.floors > 1 ? 1 : 0, cluster);\n  }\n\n  // 2. Standard Bedrooms\n  let curF = config.floors > 1 ? 1 : 0;\n  while (inventory.bedroom > 0) {\n    // Bed is always Main. \n    // If we have floating baths, we treat them as separate clusters to guarantee hall access \n    // UNLESS the user wants ensuites. Let's make 50% ensuites if available.\n    const cluster = {\n      type: 'ROOM',\n      main: 'bedroom',\n      subs: [],\n      id: `bed-${inventory.bedroom}`\n    };\n    inventory.bedroom--;\n\n    // Check for ensuite opportunity\n    if (inventory.bathroom > 0 && Math.random() > 0.5) {\n      cluster.type = 'SUITE';\n      cluster.subs.push('bathroom');\n      inventory.bathroom--;\n    }\n    assign(curF, cluster);\n    if (config.floors > 2 && curF < config.floors - 1) curF++;else if (config.floors > 1) curF = 1;\n  }\n\n  // 3. Ground Floor Service Core\n  assign(0, {\n    type: 'ROOM',\n    main: 'kitchen',\n    subs: [],\n    id: 'kitchen'\n  });\n  if (inventory.dining > 0) assign(0, {\n    type: 'ROOM',\n    main: 'dining',\n    subs: [],\n    id: 'dining'\n  });\n\n  // 4. Living / Garage (Front)\n  assign(0, {\n    type: 'ROOM',\n    main: 'living',\n    subs: [],\n    id: 'living'\n  });\n  if (inventory.garage > 0) assign(0, {\n    type: 'ROOM',\n    main: 'garage',\n    subs: [],\n    id: 'garage'\n  });\n\n  // 5. Remaining Items (Independent access required)\n  const leftovers = ['bathroom', 'utility', 'prayer', 'library', 'study', 'store'];\n  leftovers.forEach(type => {\n    while (inventory[type] > 0) {\n      // Shared baths/Utility get their own row to guarantee hall access\n      assign(0, {\n        type: 'ROOM',\n        main: type,\n        subs: [],\n        id: `${type}-shared`\n      });\n      inventory[type]--;\n    }\n  });\n  blackboard.write('floorPlans', floorPlans);\n  return true;\n};\n\n// --- AGENT 2: LAYOUT SOLVER (The Spine Stacker) ---\n_c2 = ZoningAgent;\nconst LayoutAgent = async () => {\n  LOG('Solving layout with Spine-Anchored Stacking...');\n  const site = blackboard.read('siteBoundary');\n  const floorPlans = blackboard.read('floorPlans');\n  const config = blackboard.read('config');\n  const allFloorsRegions = [];\n  const SPINE_W = 6;\n  const SPINE_X = site.x + (site.w - SPINE_W) / 2;\n  floorPlans.forEach((plan, floorIdx) => {\n    const regions = [];\n\n    // 1. Establish Spine\n    const hallRect = new Rect(SPINE_X, site.y + 6, SPINE_W, site.h - 10);\n    regions.push({\n      ...hallRect,\n      type: 'hallway'\n    });\n\n    // Stairs at back of hall\n    if (config.floors > 1) {\n      regions.push({\n        x: SPINE_X,\n        y: hallRect.bottom - 10,\n        w: SPINE_W,\n        h: 10,\n        type: 'stairs'\n      });\n      hallRect.h -= 10;\n    }\n\n    // 2. Define Wings (The Buildable Areas)\n    // Left Wing touches Hall on its RIGHT side.\n    // Right Wing touches Hall on its LEFT side.\n    const leftWing = {\n      x: site.x,\n      y: site.y,\n      w: (site.w - SPINE_W) / 2,\n      h: site.h\n    };\n    const rightWing = {\n      x: SPINE_X + SPINE_W,\n      y: site.y,\n      w: (site.w - SPINE_W) / 2,\n      h: site.h\n    };\n\n    // 3. Sort Clusters (Zoning: Back to Front)\n    // We want Kitchen/Master at top (y=0). Living/Garage at bottom.\n    const getScore = c => {\n      const name = c.main;\n      if (name.includes('kitchen') || name.includes('master')) return 0; // Rear\n      if (name.includes('dining') || name.includes('utility')) return 20;\n      if (name.includes('bed')) return 30;\n      if (name.includes('living')) return 80;\n      if (name.includes('garage')) return 90; // Front\n      return 50;\n    };\n\n    // Split into Left/Right Buckets to balance size\n    const leftClusters = [];\n    const rightClusters = [];\n    plan.clusters.sort((a, b) => getScore(a) - getScore(b));\n    plan.clusters.forEach((c, i) => {\n      // Hard constraints\n      if (c.main === 'garage') rightClusters.push(c);else if (c.main === 'kitchen') leftClusters.push(c); // Kitchen Left\n      else if (c.main === 'living') leftClusters.push(c); // Living Left\n      else if (c.main === 'dining') leftClusters.push(c);else {\n        // Balance height\n        if (leftClusters.length <= rightClusters.length) leftClusters.push(c);else rightClusters.push(c);\n      }\n    });\n\n    // 4. THE STACKER ALGORITHM\n    const stackWing = (wingRect, clusters, side) => {\n      if (clusters.length === 0) return;\n\n      // Calculate total weight to distribute height\n      const totalW = clusters.reduce((sum, c) => sum + ROOM_SPECS[c.main].weight, 0);\n      let currentY = wingRect.y;\n      clusters.forEach(c => {\n        const spec = ROOM_SPECS[c.main];\n        // Determine height of this row\n        const rowH = spec.weight / totalW * wingRect.h;\n        const rowRect = new Rect(wingRect.x, currentY, wingRect.w, rowH);\n\n        // --- CLUSTER RESOLUTION ---\n        if (c.type === 'SUITE' && c.subs.length > 0) {\n          // We have a Master + Ensuite.\n          // CONSTRAINT: Master MUST touch Hallway.\n          // SOLUTION: Split Row Vertically.\n          // If Left Wing (Side='LEFT'), Hall is on Right. -> Master goes Right, Bath goes Left.\n          // If Right Wing (Side='RIGHT'), Hall is on Left. -> Master goes Left, Bath goes Right.\n\n          const bathW = rowRect.w * 0.35; // Bath takes 35% width\n          const bedW = rowRect.w - bathW;\n          if (side === 'LEFT') {\n            // [Bath (Left)] [Bed (Right - Touches Hall)] | [Hall]\n            regions.push({\n              x: rowRect.x,\n              y: currentY,\n              w: bathW,\n              h: rowH,\n              type: c.subs[0]\n            });\n            regions.push({\n              x: rowRect.x + bathW,\n              y: currentY,\n              w: bedW,\n              h: rowH,\n              type: c.main\n            });\n          } else {\n            // [Hall] | [Bed (Left - Touches Hall)] [Bath (Right)]\n            regions.push({\n              x: rowRect.x,\n              y: currentY,\n              w: bedW,\n              h: rowH,\n              type: c.main\n            });\n            regions.push({\n              x: rowRect.x + bedW,\n              y: currentY,\n              w: bathW,\n              h: rowH,\n              type: c.subs[0]\n            });\n          }\n        } else {\n          // Single Room (Standard)\n          // Takes full width, guarantees Hall access.\n          regions.push({\n            ...rowRect,\n            type: c.main\n          });\n        }\n        currentY += rowH;\n      });\n    };\n    stackWing(leftWing, leftClusters, 'LEFT');\n    stackWing(rightWing, rightClusters, 'RIGHT');\n    allFloorsRegions.push(regions);\n  });\n  blackboard.write('floorRegions', allFloorsRegions);\n  return true;\n};\n\n// --- AGENT 3: STRUCTURAL ---\n_c3 = LayoutAgent;\nconst StructuralAgent = async () => {\n  LOG('Building Walls...');\n  const floorRegions = blackboard.read('floorRegions');\n  const allWalls = [];\n  floorRegions.forEach(rooms => {\n    const walls = [];\n    rooms.forEach(r => {\n      walls.push({\n        x1: r.x,\n        y1: r.y,\n        x2: r.x + r.w,\n        y2: r.y,\n        type: 'inner'\n      });\n      walls.push({\n        x1: r.x,\n        y1: r.y + r.h,\n        x2: r.x + r.w,\n        y2: r.y + r.h,\n        type: 'inner'\n      });\n      walls.push({\n        x1: r.x,\n        y1: r.y,\n        x2: r.x,\n        y2: r.y + r.h,\n        type: 'inner'\n      });\n      walls.push({\n        x1: r.x + r.w,\n        y1: r.y,\n        x2: r.x + r.w,\n        y2: r.y + r.h,\n        type: 'inner'\n      });\n    });\n    const b = blackboard.read('siteBoundary');\n    const outer = [{\n      x1: b.x,\n      y1: b.y,\n      x2: b.x + b.w,\n      y2: b.y\n    }, {\n      x1: b.x,\n      y1: b.y + b.h,\n      x2: b.x + b.w,\n      y2: b.y + b.h\n    }, {\n      x1: b.x,\n      y1: b.y,\n      x2: b.x,\n      y2: b.y + b.h\n    }, {\n      x1: b.x + b.w,\n      y1: b.y,\n      x2: b.x + b.w,\n      y2: b.y + b.h\n    }];\n    allWalls.push({\n      inner: walls,\n      outer: outer\n    });\n  });\n  blackboard.write('floorWalls', allWalls);\n  return true;\n};\n\n// --- AGENT 4: DOORS (Strict Access) ---\n_c4 = StructuralAgent;\nconst ConnectivityAgent = async () => {\n  LOG('Placing Doors...');\n  const floorRegions = blackboard.read('floorRegions');\n  const allDoors = [];\n  floorRegions.forEach((rooms, floorIndex) => {\n    const doors = [];\n    const addDoor = d => {\n      if (!doors.some(x => Math.abs(x.x - d.x) < 1 && Math.abs(x.y - d.y) < 1)) doors.push(d);\n    };\n    rooms.forEach((r1, i) => {\n      rooms.forEach((r2, j) => {\n        if (i <= j) return;\n\n        // Check adjacency\n        const overlapX = Math.min(r1.x + r1.w, r2.x + r2.w) - Math.max(r1.x, r2.x);\n        const overlapY = Math.min(r1.y + r1.h, r2.y + r2.h) - Math.max(r1.y, r2.y);\n        const touchX = Math.abs(r1.x + r1.w - r2.x) < 0.1 || Math.abs(r2.x + r2.w - r1.x) < 0.1;\n        const touchY = Math.abs(r1.y + r1.h - r2.y) < 0.1 || Math.abs(r2.y + r2.h - r1.y) < 0.1;\n\n        // Logic: Who connects to whom?\n        const r1Hall = r1.type === 'hallway';\n        const r2Hall = r2.type === 'hallway';\n\n        // 1. Hallway Access (Priority)\n        if (r1Hall || r2Hall) {\n          // Almost everything connects to hall\n          if (touchX && overlapY > 3) addDoor({\n            x: r1.x < r2.x ? r2.x : r1.x,\n            y: Math.max(r1.y, r2.y) + overlapY / 2 - 1.5,\n            w: 3,\n            vertical: true\n          });else if (touchY && overlapX > 3) addDoor({\n            x: Math.max(r1.x, r2.x) + overlapX / 2 - 1.5,\n            y: r1.y < r2.y ? r2.y : r1.y,\n            w: 3,\n            vertical: false\n          });\n        }\n\n        // 2. Ensuite Access (Bed <-> Bath)\n        // If they touch, put a door.\n        const r1Bath = r1.type === 'bathroom';\n        const r2Bath = r2.type === 'bathroom';\n        const r1Bed = r1.type.includes('bed');\n        const r2Bed = r2.type.includes('bed');\n        if (r1Bath && r2Bed || r2Bath && r1Bed) {\n          if (touchX && overlapY > 3) addDoor({\n            x: r1.x < r2.x ? r2.x : r1.x,\n            y: Math.max(r1.y, r2.y) + overlapY / 2 - 1.5,\n            w: 3,\n            vertical: true\n          });\n        }\n      });\n    });\n\n    // Front Door\n    if (floorIndex === 0) {\n      const hall = rooms.find(r => r.type === 'hallway');\n      if (hall) addDoor({\n        x: hall.x + hall.w / 2 - 2,\n        y: hall.y + hall.h,\n        w: 4,\n        vertical: false\n      });\n    }\n    allDoors.push(doors);\n  });\n  blackboard.write('floorDoors', allDoors);\n  return true;\n};\n_c5 = ConnectivityAgent;\nexport const agents = [{\n  name: 'Zoning & Logic',\n  fn: ZoningAgent\n}, {\n  name: 'Spine-Stacker Layout',\n  fn: LayoutAgent\n}, {\n  name: 'Structural Skeleton',\n  fn: StructuralAgent\n}, {\n  name: 'Access Grapher',\n  fn: ConnectivityAgent\n}];\nvar _c, _c2, _c3, _c4, _c5;\n$RefreshReg$(_c, \"LOG\");\n$RefreshReg$(_c2, \"ZoningAgent\");\n$RefreshReg$(_c3, \"LayoutAgent\");\n$RefreshReg$(_c4, \"StructuralAgent\");\n$RefreshReg$(_c5, \"ConnectivityAgent\");","map":{"version":3,"names":["blackboard","LOG","msg","console","log","_c","ROOM_SPECS","weight","minDim","color","label","Rect","constructor","x","y","w","h","right","bottom","ZoningAgent","config","pad","buildW","width","buildD","depth","write","inventory","rooms","floorPlans","Array","from","length","floors","clusters","assign","fIdx","cluster","f","Math","min","push","bedroom","type","main","subs","id","bathroom","curF","random","dining","garage","leftovers","forEach","_c2","LayoutAgent","site","read","allFloorsRegions","SPINE_W","SPINE_X","plan","floorIdx","regions","hallRect","leftWing","rightWing","getScore","c","name","includes","leftClusters","rightClusters","sort","a","b","i","stackWing","wingRect","side","totalW","reduce","sum","currentY","spec","rowH","rowRect","bathW","bedW","_c3","StructuralAgent","floorRegions","allWalls","walls","r","x1","y1","x2","y2","outer","inner","_c4","ConnectivityAgent","allDoors","floorIndex","doors","addDoor","d","some","abs","r1","r2","j","overlapX","max","overlapY","touchX","touchY","r1Hall","r2Hall","vertical","r1Bath","r2Bath","r1Bed","r2Bed","hall","find","_c5","agents","fn","$RefreshReg$"],"sources":["E:/PAP/SEM 5  (Current)/Agent Based Software Engineering (ABSE)/Schematic-Architecture-Generator/ShamArchitectSys_Final/src/agents/AgentSystem.js"],"sourcesContent":["import { blackboard } from '../core/Blackboard';\n\n/**\n * ==================================================================================\n * SHAM ARCHITECT SYS - PRO GEN 6.0 (DIRECT ACCESS SOLVER)\n * ==================================================================================\n * Key Feature: \"Spine-Anchored Layout\"\n * Ensures every primary room touches the central hallway.\n */\n\nconst LOG = (msg) => console.log(`[Architect Core] ${msg}`);\n\n// ==================================================================================\n// 1. ARCHITECTURAL KNOWLEDGE BASE\n// ==================================================================================\n\nconst ROOM_SPECS = {\n  // Weights determine relative height/size of the room in the stack\n  'living':     { weight: 2.2, minDim: 14, color: '#fff7ed', label: 'Living Room' },\n  'dining':     { weight: 1.4, minDim: 11, color: '#fffbeb', label: 'Dining' },\n  'garage':     { weight: 2.0, minDim: 12, color: '#f1f5f9', label: 'Garage' },\n  'kitchen':    { weight: 1.5, minDim: 11, color: '#ecfeff', label: 'Kitchen' },\n  'master-bed': { weight: 1.8, minDim: 13, color: '#f0f9ff', label: 'Master Suite' },\n  'bedroom':    { weight: 1.3, minDim: 10, color: '#f0f9ff', label: 'Bedroom' },\n  'study':      { weight: 1.0, minDim: 9,  color: '#fefce8', label: 'Study' },\n  'library':    { weight: 1.2, minDim: 10, color: '#fefce8', label: 'Library' },\n  'bathroom':   { weight: 0.8, minDim: 6,  color: '#f8fafc', label: 'Bath' }, // Independent Bath\n  'utility':    { weight: 0.9, minDim: 7,  color: '#f3f4f6', label: 'Laundry' },\n  'prayer':     { weight: 0.8, minDim: 7,  color: '#f0fdf4', label: 'Prayer' },\n  'store':      { weight: 0.5, minDim: 5,  color: '#cbd5e1', label: 'Store' },\n  \n  // Circulation\n  'hallway':    { weight: 0,   minDim: 4,  color: '#ffffff', label: 'Hallway' },\n  'stairs':     { weight: 0,   minDim: 8,  color: '#e2e8f0', label: 'Stairs' }\n};\n\n// ==================================================================================\n// 2. GEOMETRY ENGINE\n// ==================================================================================\n\nclass Rect {\n  constructor(x, y, w, h) {\n    this.x = x; this.y = y; this.w = w; this.h = h;\n  }\n  get right() { return this.x + this.w; }\n  get bottom() { return this.y + this.h; }\n}\n\n// ==================================================================================\n// 3. AGENT IMPLEMENTATIONS\n// ==================================================================================\n\n// --- AGENT 1: ZONING (Assigns Logic) ---\nconst ZoningAgent = async (config) => {\n  LOG('Zoning rooms with direct-access priority...');\n  \n  const pad = 4;\n  const buildW = config.width - (pad*2);\n  const buildD = config.depth - (pad*2);\n  blackboard.write('siteBoundary', new Rect(pad, pad, buildW, buildD));\n  \n  const inventory = { ...config.rooms };\n  const floorPlans = Array.from({ length: config.floors }, () => ({ clusters: [] }));\n\n  const assign = (fIdx, cluster) => {\n    const f = Math.min(fIdx, config.floors - 1);\n    floorPlans[f].clusters.push(cluster);\n  };\n\n  // --- CLUSTER LOGIC ---\n  // A \"Cluster\" is a row in the stack. \n  // It can be a Single Room (Direct Access) or a Suite (Master + Ensuite).\n  \n  // 1. Master Suite (Priority 1)\n  if (inventory.bedroom > 0) {\n    const cluster = { type: 'SUITE', main: 'master-bed', subs: [], id: 'master' };\n    inventory.bedroom--;\n    if (inventory.bathroom > 0) { cluster.subs.push('bathroom'); inventory.bathroom--; }\n    assign(config.floors > 1 ? 1 : 0, cluster);\n  }\n\n  // 2. Standard Bedrooms\n  let curF = config.floors > 1 ? 1 : 0;\n  while (inventory.bedroom > 0) {\n    // Bed is always Main. \n    // If we have floating baths, we treat them as separate clusters to guarantee hall access \n    // UNLESS the user wants ensuites. Let's make 50% ensuites if available.\n    const cluster = { type: 'ROOM', main: 'bedroom', subs: [], id: `bed-${inventory.bedroom}` };\n    inventory.bedroom--;\n    \n    // Check for ensuite opportunity\n    if (inventory.bathroom > 0 && Math.random() > 0.5) {\n       cluster.type = 'SUITE';\n       cluster.subs.push('bathroom');\n       inventory.bathroom--;\n    }\n    assign(curF, cluster);\n    \n    if (config.floors > 2 && curF < config.floors - 1) curF++;\n    else if (config.floors > 1) curF = 1;\n  }\n\n  // 3. Ground Floor Service Core\n  assign(0, { type: 'ROOM', main: 'kitchen', subs: [], id: 'kitchen' });\n  if (inventory.dining > 0) assign(0, { type: 'ROOM', main: 'dining', subs: [], id: 'dining' });\n  \n  // 4. Living / Garage (Front)\n  assign(0, { type: 'ROOM', main: 'living', subs: [], id: 'living' });\n  if (inventory.garage > 0) assign(0, { type: 'ROOM', main: 'garage', subs: [], id: 'garage' });\n\n  // 5. Remaining Items (Independent access required)\n  const leftovers = ['bathroom', 'utility', 'prayer', 'library', 'study', 'store'];\n  leftovers.forEach(type => {\n    while (inventory[type] > 0) {\n      // Shared baths/Utility get their own row to guarantee hall access\n      assign(0, { type: 'ROOM', main: type, subs: [], id: `${type}-shared` });\n      inventory[type]--;\n    }\n  });\n\n  blackboard.write('floorPlans', floorPlans);\n  return true;\n};\n\n// --- AGENT 2: LAYOUT SOLVER (The Spine Stacker) ---\nconst LayoutAgent = async () => {\n  LOG('Solving layout with Spine-Anchored Stacking...');\n  \n  const site = blackboard.read('siteBoundary');\n  const floorPlans = blackboard.read('floorPlans');\n  const config = blackboard.read('config');\n  const allFloorsRegions = [];\n\n  const SPINE_W = 6;\n  const SPINE_X = site.x + (site.w - SPINE_W) / 2;\n\n  floorPlans.forEach((plan, floorIdx) => {\n    const regions = [];\n    \n    // 1. Establish Spine\n    const hallRect = new Rect(SPINE_X, site.y + 6, SPINE_W, site.h - 10);\n    regions.push({ ...hallRect, type: 'hallway' });\n    \n    // Stairs at back of hall\n    if (config.floors > 1) {\n       regions.push({ x: SPINE_X, y: hallRect.bottom - 10, w: SPINE_W, h: 10, type: 'stairs' });\n       hallRect.h -= 10;\n    }\n\n    // 2. Define Wings (The Buildable Areas)\n    // Left Wing touches Hall on its RIGHT side.\n    // Right Wing touches Hall on its LEFT side.\n    const leftWing = { x: site.x, y: site.y, w: (site.w - SPINE_W)/2, h: site.h };\n    const rightWing = { x: SPINE_X + SPINE_W, y: site.y, w: (site.w - SPINE_W)/2, h: site.h };\n\n    // 3. Sort Clusters (Zoning: Back to Front)\n    // We want Kitchen/Master at top (y=0). Living/Garage at bottom.\n    const getScore = (c) => {\n       const name = c.main;\n       if (name.includes('kitchen') || name.includes('master')) return 0; // Rear\n       if (name.includes('dining') || name.includes('utility')) return 20;\n       if (name.includes('bed')) return 30;\n       if (name.includes('living')) return 80;\n       if (name.includes('garage')) return 90; // Front\n       return 50;\n    };\n\n    // Split into Left/Right Buckets to balance size\n    const leftClusters = [];\n    const rightClusters = [];\n    \n    plan.clusters.sort((a,b) => getScore(a) - getScore(b));\n    \n    plan.clusters.forEach((c, i) => {\n      // Hard constraints\n      if (c.main === 'garage') rightClusters.push(c);\n      else if (c.main === 'kitchen') leftClusters.push(c); // Kitchen Left\n      else if (c.main === 'living') leftClusters.push(c);  // Living Left\n      else if (c.main === 'dining') leftClusters.push(c);\n      else {\n         // Balance height\n         if (leftClusters.length <= rightClusters.length) leftClusters.push(c);\n         else rightClusters.push(c);\n      }\n    });\n\n    // 4. THE STACKER ALGORITHM\n    const stackWing = (wingRect, clusters, side) => {\n       if (clusters.length === 0) return;\n       \n       // Calculate total weight to distribute height\n       const totalW = clusters.reduce((sum, c) => sum + (ROOM_SPECS[c.main].weight), 0);\n       let currentY = wingRect.y;\n\n       clusters.forEach(c => {\n          const spec = ROOM_SPECS[c.main];\n          // Determine height of this row\n          const rowH = (spec.weight / totalW) * wingRect.h;\n          const rowRect = new Rect(wingRect.x, currentY, wingRect.w, rowH);\n          \n          // --- CLUSTER RESOLUTION ---\n          if (c.type === 'SUITE' && c.subs.length > 0) {\n             // We have a Master + Ensuite.\n             // CONSTRAINT: Master MUST touch Hallway.\n             // SOLUTION: Split Row Vertically.\n             // If Left Wing (Side='LEFT'), Hall is on Right. -> Master goes Right, Bath goes Left.\n             // If Right Wing (Side='RIGHT'), Hall is on Left. -> Master goes Left, Bath goes Right.\n             \n             const bathW = rowRect.w * 0.35; // Bath takes 35% width\n             const bedW = rowRect.w - bathW;\n             \n             if (side === 'LEFT') {\n                // [Bath (Left)] [Bed (Right - Touches Hall)] | [Hall]\n                regions.push({ x: rowRect.x, y: currentY, w: bathW, h: rowH, type: c.subs[0] });\n                regions.push({ x: rowRect.x + bathW, y: currentY, w: bedW, h: rowH, type: c.main });\n             } else {\n                // [Hall] | [Bed (Left - Touches Hall)] [Bath (Right)]\n                regions.push({ x: rowRect.x, y: currentY, w: bedW, h: rowH, type: c.main });\n                regions.push({ x: rowRect.x + bedW, y: currentY, w: bathW, h: rowH, type: c.subs[0] });\n             }\n\n          } else {\n             // Single Room (Standard)\n             // Takes full width, guarantees Hall access.\n             regions.push({ ...rowRect, type: c.main });\n          }\n\n          currentY += rowH;\n       });\n    };\n\n    stackWing(leftWing, leftClusters, 'LEFT');\n    stackWing(rightWing, rightClusters, 'RIGHT');\n    \n    allFloorsRegions.push(regions);\n  });\n\n  blackboard.write('floorRegions', allFloorsRegions);\n  return true;\n};\n\n// --- AGENT 3: STRUCTURAL ---\nconst StructuralAgent = async () => {\n  LOG('Building Walls...');\n  const floorRegions = blackboard.read('floorRegions');\n  const allWalls = [];\n\n  floorRegions.forEach((rooms) => {\n    const walls = [];\n    rooms.forEach(r => {\n      walls.push({ x1: r.x, y1: r.y, x2: r.x+r.w, y2: r.y, type: 'inner' });\n      walls.push({ x1: r.x, y1: r.y+r.h, x2: r.x+r.w, y2: r.y+r.h, type: 'inner' });\n      walls.push({ x1: r.x, y1: r.y, x2: r.x, y2: r.y+r.h, type: 'inner' });\n      walls.push({ x1: r.x+r.w, y1: r.y, x2: r.x+r.w, y2: r.y+r.h, type: 'inner' });\n    });\n    \n    const b = blackboard.read('siteBoundary');\n    const outer = [\n      { x1: b.x, y1: b.y, x2: b.x+b.w, y2: b.y },\n      { x1: b.x, y1: b.y+b.h, x2: b.x+b.w, y2: b.y+b.h },\n      { x1: b.x, y1: b.y, x2: b.x, y2: b.y+b.h },\n      { x1: b.x+b.w, y1: b.y, x2: b.x+b.w, y2: b.y+b.h },\n    ];\n    allWalls.push({ inner: walls, outer: outer });\n  });\n  blackboard.write('floorWalls', allWalls);\n  return true;\n};\n\n// --- AGENT 4: DOORS (Strict Access) ---\nconst ConnectivityAgent = async () => {\n  LOG('Placing Doors...');\n  const floorRegions = blackboard.read('floorRegions');\n  const allDoors = [];\n\n  floorRegions.forEach((rooms, floorIndex) => {\n    const doors = [];\n    const addDoor = (d) => { if(!doors.some(x=>Math.abs(x.x-d.x)<1 && Math.abs(x.y-d.y)<1)) doors.push(d); };\n\n    rooms.forEach((r1, i) => {\n      rooms.forEach((r2, j) => {\n        if(i <= j) return;\n        \n        // Check adjacency\n        const overlapX = (Math.min(r1.x+r1.w, r2.x+r2.w) - Math.max(r1.x, r2.x));\n        const overlapY = (Math.min(r1.y+r1.h, r2.y+r2.h) - Math.max(r1.y, r2.y));\n        const touchX = Math.abs(r1.x+r1.w - r2.x) < 0.1 || Math.abs(r2.x+r2.w - r1.x) < 0.1;\n        const touchY = Math.abs(r1.y+r1.h - r2.y) < 0.1 || Math.abs(r2.y+r2.h - r1.y) < 0.1;\n\n        // Logic: Who connects to whom?\n        const r1Hall = r1.type === 'hallway';\n        const r2Hall = r2.type === 'hallway';\n        \n        // 1. Hallway Access (Priority)\n        if (r1Hall || r2Hall) {\n           // Almost everything connects to hall\n           if (touchX && overlapY > 3) addDoor({x: (r1.x<r2.x?r2.x:r1.x), y: Math.max(r1.y,r2.y)+overlapY/2-1.5, w:3, vertical:true});\n           else if (touchY && overlapX > 3) addDoor({x: Math.max(r1.x,r2.x)+overlapX/2-1.5, y: (r1.y<r2.y?r2.y:r1.y), w:3, vertical:false});\n        }\n        \n        // 2. Ensuite Access (Bed <-> Bath)\n        // If they touch, put a door.\n        const r1Bath = r1.type === 'bathroom';\n        const r2Bath = r2.type === 'bathroom';\n        const r1Bed = r1.type.includes('bed');\n        const r2Bed = r2.type.includes('bed');\n        \n        if ((r1Bath && r2Bed) || (r2Bath && r1Bed)) {\n           if (touchX && overlapY > 3) addDoor({x: (r1.x<r2.x?r2.x:r1.x), y: Math.max(r1.y,r2.y)+overlapY/2-1.5, w:3, vertical:true});\n        }\n      });\n    });\n    \n    // Front Door\n    if(floorIndex === 0) {\n       const hall = rooms.find(r=>r.type === 'hallway');\n       if(hall) addDoor({x: hall.x+hall.w/2-2, y: hall.y+hall.h, w:4, vertical:false});\n    }\n\n    allDoors.push(doors);\n  });\n  blackboard.write('floorDoors', allDoors);\n  return true;\n};\n\nexport const agents = [\n  { name: 'Zoning & Logic', fn: ZoningAgent },\n  { name: 'Spine-Stacker Layout', fn: LayoutAgent },\n  { name: 'Structural Skeleton', fn: StructuralAgent },\n  { name: 'Access Grapher', fn: ConnectivityAgent },\n];"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}